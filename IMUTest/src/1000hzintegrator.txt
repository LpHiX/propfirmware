#include <Arduino.h>
#include <Wire.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_MPU6050.h>
#include <QMC5883LCompass.h> // Changed from HMC5883L to QMC5883L
#include <Adafruit_BMP085_U.h>
#include <Adafruit_NeoPixel.h>

// Sensor objects
Adafruit_MPU6050 mpu;
QMC5883LCompass compass; // Changed magnetometer object
Adafruit_BMP085_Unified bmp = Adafruit_BMP085_Unified(10085);

// NeoPixel configuration
#define NEOPIXEL_PIN      48
#define NEOPIXEL_COUNT    1
#define BLINK_INTERVAL    5000  // 5 seconds between blinks
Adafruit_NeoPixel pixels(NEOPIXEL_COUNT, NEOPIXEL_PIN, NEO_GRB + NEO_KHZ800);
unsigned long lastBlinkTime = 0;
bool pixelState = false;

// Sensor status flags
bool mpuReady = false;
bool magReady = false;
bool bmpReady = false;

// Define I2C pins (adjust these values based on your specific board and needs)
const int SDA_PIN = 16; // Default SDA pin on ESP32
const int SCL_PIN = 17; // Default SCL pin on ESP32

// Position tracking variables
float accel[3] = {0, 0, 0};              // Current acceleration (x, y, z)
float gravityAccel[3] = {0, 0, 0};       // Average gravity vector
float accelWithoutGravity[3] = {0, 0, 0}; // Acceleration minus gravity
float velocity[3] = {0, 0, 0};           // Velocity (x, y, z)
float position[3] = {0, 0, 0};           // Position (x, y, z)

// Calibration variables
float calibrationData[3][100];           // Store 100 samples for calibration
int calibrateNumber = 0;                 // Current calibration sample
bool isCalibrated = false;               // Calibration status

// Timing control
unsigned long lastSensorReadTime = 0;    // For 1000Hz sensor reading
unsigned long lastPositionUpdateTime = 0; // For 20Hz position output
const unsigned long SENSOR_READ_INTERVAL = 1;    // 1ms (1000Hz)
const unsigned long POSITION_OUTPUT_INTERVAL = 500; // 50ms (20Hz)
unsigned long lastTime = 0;              // For dt calculation

// Position tracking functions
void calibrateSensors() {
  // Store current acceleration in calibration array
  calibrationData[0][calibrateNumber] = accel[0];
  calibrationData[1][calibrateNumber] = accel[1];
  calibrationData[2][calibrateNumber] = accel[2];
  
  Serial.print("Calibrating... ");
  Serial.print(calibrateNumber + 1);
  Serial.println("/100");
  
  calibrateNumber++;
  
  // If we've collected 100 samples, compute average gravity
  if (calibrateNumber == 100) {
    // Calculate average gravity vector (skip first sample)
    for (int axis = 0; axis < 3; axis++) {
      float sum = 0;
      for (int i = 1; i < 99; i++) {
        sum += calibrationData[axis][i];
      }
      gravityAccel[axis] = sum / 98.0;
    }
    
    Serial.print("Calibration complete. Gravity vector: [");
    Serial.print(gravityAccel[0], 3);
    Serial.print(", ");
    Serial.print(gravityAccel[1], 3);
    Serial.print(", ");
    Serial.print(gravityAccel[2], 3);
    Serial.println("]");
    
    isCalibrated = true;
    lastTime = micros();
  }
}

void updatePosition() {
  // Calculate time difference in seconds
  unsigned long currentTime = micros();
  float dt = (currentTime - lastTime) / 1000000.0; // Convert microseconds to seconds
  lastTime = currentTime;
  
  // Remove gravity component
  for (int i = 0; i < 3; i++) {
    accelWithoutGravity[i] = accel[i] - gravityAccel[i];
    
    // Apply simple noise filtering
    const float threshold = 0.05; // m/sÂ²
    if (abs(accelWithoutGravity[i]) < threshold) {
      accelWithoutGravity[i] = 0;
    }
  }
  
  // First integration: acceleration -> velocity
  for (int i = 0; i < 3; i++) {
    velocity[i] += accelWithoutGravity[i] * dt;
    
    // Apply velocity decay to counter drift
    const float decayFactor = 0.995; // Adjust as needed
    velocity[i] *= decayFactor;
  }
  
  // Second integration: velocity -> position
  for (int i = 0; i < 3; i++) {
    position[i] += velocity[i] * dt;
  }
}

void printPositionData() {
  // Print acceleration data
  Serial.print("Raw Accel: X=");
  Serial.print(accel[0], 3);
  Serial.print(", Y=");
  Serial.print(accel[1], 3);
  Serial.print(", Z=");
  Serial.println(accel[2], 3);
  
  // Print acceleration without gravity
  Serial.print("Accel-G: X=");
  Serial.print(accelWithoutGravity[0], 3);
  Serial.print(", Y=");
  Serial.print(accelWithoutGravity[1], 3);
  Serial.print(", Z=");
  Serial.println(accelWithoutGravity[2], 3);
  
  // Print velocity
  Serial.print("Velocity: X=");
  Serial.print(velocity[0], 3);
  Serial.print(", Y=");
  Serial.print(velocity[1], 3);
  Serial.print(", Z=");
  Serial.println(velocity[2], 3);
  
  // Print position
  Serial.print("Position: X=");
  Serial.print(position[0], 3);
  Serial.print(", Y=");
  Serial.print(position[1], 3);
  Serial.print(", Z=");
  Serial.println(position[2], 3);
  Serial.println("---------------------");
}

void setup() {
  // Initialize serial for debugging
  Serial.begin(921600);
  while (!Serial) delay(10); // Wait for serial console
  
  Serial.println("GY-87 10DOF Sensor Test");
  
  // Initialize NeoPixel
  pixels.begin();
  pixels.clear();
  pixels.show();
  Serial.printf("NeoPixel initialized on pin %d\n", NEOPIXEL_PIN);
  
  // Initialize I2C with custom pins
  Wire.begin(SDA_PIN, SCL_PIN);
  Serial.printf("I2C initialized with custom pins: SDA=%d, SCL=%d\n", SDA_PIN, SCL_PIN);
  
  // Initialize MPU6050
  if (mpu.begin()) {
    Serial.println("MPU6050 found!");
    mpuReady = true;
    
    // MPU6050 settings
    mpu.setAccelerometerRange(MPU6050_RANGE_2_G);
    mpu.setGyroRange(MPU6050_RANGE_500_DEG);
    mpu.setFilterBandwidth(MPU6050_BAND_5_HZ);
    
    // Enable I2C bypass to access HMC5883L
    Wire.beginTransmission(0x68); // MPU6050 address
    Wire.write(0x37);             // Register: INT_PIN_CFG
    Wire.write(0x02);             // Enable I2C bypass
    Wire.endTransmission(true);
  } else {
    Serial.println("Failed to find MPU6050!");
  }
  
  delay(50); // Wait for bypass to take effect
  
  // Initialize NeoPixel
  pixels.begin();
  pixels.show(); // Initialize all pixels to 'off'
  
  Serial.println("Setup complete.");
  Serial.println("Starting calibration. Keep the sensor still...");
}

void loop() {
  unsigned long currentMillis = millis();
  
  // Check if it's time to blink the NeoPixel
  if (currentMillis - lastBlinkTime >= BLINK_INTERVAL) {
    lastBlinkTime = currentMillis;
    pixelState = !pixelState;
    
    if (pixelState) {
      pixels.setPixelColor(0, pixels.Color(0, 150, 0));  // Green
    } else {
      pixels.clear();
    }
    pixels.show();
  }
  
  // Read sensor at 1000Hz (1ms)
  if (currentMillis - lastSensorReadTime >= SENSOR_READ_INTERVAL) {
    lastSensorReadTime = currentMillis;
    
    // Variables to store sensor data
    sensors_event_t a, g, temp;
    
    // Read MPU6050 data
    if (mpuReady) {
      mpu.getEvent(&a, &g, &temp);
      
      // Store acceleration data
      accel[0] = a.acceleration.x;
      accel[1] = a.acceleration.y;
      accel[2] = a.acceleration.z;
      
      // Either calibrate or update position
      if (!isCalibrated) {
        calibrateSensors();
      } else {
        updatePosition();
      }
    }
  }
  
  // Output position data at 20Hz (50ms)
  if (isCalibrated && (currentMillis - lastPositionUpdateTime >= POSITION_OUTPUT_INTERVAL)) {
    lastPositionUpdateTime = currentMillis;
    printPositionData();
  }
}